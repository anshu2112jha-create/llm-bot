#pip install pandas openpyxl python-dotenv

import os
import time
import json
import warnings
import requests
import math
from dotenv import load_dotenv
import pandas as pd
from pathlib import Path

# -----------------------------
# Basic config / environment
# -----------------------------
warnings.filterwarnings("ignore")  # suppress SSL warnings for internal APIs

# load CLIENT_ID and CLIENT_SECRET from .env
load_dotenv()

CLIENT_ID = os.getenv("CLIENT_ID", "")
CLIENT_SECRET = os.getenv("CLIENT_SECRET", "")

# Put your Excel path here (explicit in code per your request)
EXCEL_FILE_PATH = r"C:\Users\5306112\OneDrive - Lowe's Companies Inc\Desktop\Test_data 19 dec\Plumbing_RR_sample.xlsx"   # <-- set this to your actual file path

# API endpoints / model
TOKEN_URL = "https://apis-b2b-dev.lowes.com/v1/oauthprovider/oauth2/token"
CHAT_URL  = "https://apis-b2b-dev.lowes.com/llama3/v1/chat/completions"
MODEL_NAME = "meta-llama/Meta-Llama-3.1-8B-Instruct"

# LLM call settings
LLM_CALL_PAUSE = 0.3   # seconds between calls (increase if you hit rate limits)
LLM_TIMEOUT = 15       # seconds per call
VERIFY_SSL = False     # set True in production if you have valid certs

# -----------------------------
# Token cache + fetch
# -----------------------------
_access_token = None
_token_expiry = 0.0

def get_access_token():
    """
    Return a valid access token. Refresh automatically when expired.
    """
    global _access_token, _token_expiry

    if _access_token and time.time() < _token_expiry:
        return _access_token

    if not CLIENT_ID or not CLIENT_SECRET:
        raise RuntimeError("CLIENT_ID and CLIENT_SECRET must be set in your .env")

    payload = {
        "client_id": CLIENT_ID,
        "client_secret": CLIENT_SECRET,
        "grant_type": "client_credentials"
    }
    headers = {"Content-Type": "application/x-www-form-urlencoded"}

    resp = requests.post(TOKEN_URL, data=payload, headers=headers, verify=VERIFY_SSL, timeout=10)
    resp.raise_for_status()
    data = resp.json()

    _access_token = data.get("access_token")
    expires_in = int(data.get("expires_in", 900))
    _token_expiry = time.time() + expires_in - 30  # refresh margin

    print("üîë Token refreshed")
    return _access_token

# -----------------------------
# LLM single-row extractor
# -----------------------------
def call_llm_for_location(problem_text: str, timeout: int = LLM_TIMEOUT) -> str:
    """
    Call the chat completions endpoint to extract a physical location from problem_text.
    Returns a single-line string (location) or "UNKNOWN".
    """

    if not problem_text or str(problem_text).strip() == "":
        return "UNKNOWN"

    token = get_access_token()
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
        "Accept": "application/json"
    }

    system_msg = (
        "You are a Data analyst expert. Extract ONLY the physical location from the user's text. "
        "Physical locations are short phrases like 'Garden Center', 'Parking lot, Restroom', 'Bathroom', "
        "'Building Interior', etc. "
        "If there is NO physical location in the text, respond exactly with UNKNOWN. "
        "Return the location as a single short line with no extra commentary."
    )

    user_msg = (
        "Problem Description:\n\"\"\"\n" + str(problem_text).strip() + "\n\"\"\"\n\nReturn only the physical location or UNKNOWN."
    )

    payload = {
        "model": MODEL_NAME,
        "messages": [
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_msg}
        ],
        "temperature": 0,
        "top_p": 1,
        "max_tokens": 80,
        "presence_penalty": 0,
        "frequency_penalty": 0,
        "user": "location-extractor"
    }

    resp = requests.post(CHAT_URL, headers=headers, json=payload, timeout=timeout, verify=VERIFY_SSL)

    # Refresh token and retry once on 401
    if resp.status_code == 401:
        get_access_token()  # refresh into _access_token
        headers["Authorization"] = f"Bearer {_access_token}"
        resp = requests.post(CHAT_URL, headers=headers, json=payload, timeout=timeout, verify=VERIFY_SSL)

    resp.raise_for_status()
    data = resp.json()

    # Defensive parsing of response
    text = ""
    try:
        text = data["choices"][0]["message"]["content"].strip()
    except Exception:
        try:
            # fallback if shape differs
            text = str(data["choices"][0]).strip()
        except Exception:
            text = ""

    if not text:
        return "UNKNOWN"

    # return first non-empty line, normalized
    for line in text.splitlines():
        l = line.strip()
        if l:
            # collapse whitespace
            l = " ".join(l.split())
            if len(l) > 200:
                l = l[:200]
            return l
    return "UNKNOWN"

# -----------------------------
# File processing: Excel only
# -----------------------------
def extract_physical_location_with_llm_and_write():
    """
    Read EXCEL_FILE_PATH, iterate Problem Description rows, call LLM to extract locations,
    append 'Physical Location' column, and write new Excel file next to source.
    """
    src = Path(EXCEL_FILE_PATH)
    if not src.exists():
        print(f"‚ö† Input Excel file not found: {EXCEL_FILE_PATH}")
        return None

    # Read first sheet
    df = pd.read_excel(src, sheet_name=0)
    if "Problem Description" not in df.columns:
        print("‚ö† Column 'Problem Description' not found in the file. Available columns:", df.columns.tolist())
        return None

    locations = []
    total = len(df)
    print(f"‚ÑπÔ∏è Processing {total} rows with LLM calls (one call per row)...")

    for idx, val in df["Problem Description"].items():
        # handle NaN
        if pd.isna(val) or (isinstance(val, float) and math.isnan(val)):
            locations.append("UNKNOWN")
            continue

        text = str(val)
        try:
            loc = call_llm_for_location(text)
            if not loc:
                loc = "UNKNOWN"
        except Exception as e:
            print(f"‚ö† Error extracting for row {idx}: {e}")
            loc = "UNKNOWN"

        locations.append(loc)
        time.sleep(LLM_CALL_PAUSE)

    df["Physical Location"] = locations

    out_path = src.with_name(src.stem + "_with_location.xlsx")
    df.to_excel(out_path, index=False)
    print(f"‚úÖ Wrote output with new column: {out_path}")
    return out_path

# -----------------------------
# Main execution
# -----------------------------
if __name__ == "__main__":
    # Run extraction first (keeps your current behavior)
    extract_physical_location_with_llm_and_write()

    # Then start an interactive single-turn chat loop
    print("\nüí¨ Interactive chat (single-turn). Type 'exit' to quit.\n")
    while True:
        try:
            user_input = input("You: ").strip()
        except (KeyboardInterrupt, EOFError):
            print()
            break

        if not user_input:
            continue
        if user_input.lower() in ("exit", "quit"):
            break

        try:
            answer = single_turn_chat(user_input)
            print("Bot:", answer, "\n")
        except Exception as e:
            print("‚ùå Error:", e)
            # if token expired or network hiccup, you can continue the loop
            continue

    print("Goodbye.")

    # Run extraction first
    extract_physical_location_with_llm_and_write()

    # If you still want the interactive chat loop afterwards, you can reuse your original chat flow.
    # For brevity this script ends after extraction.
    print("Done.")
